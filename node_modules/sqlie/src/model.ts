import {IInsertBuilder, InsertBuilder} from './builder/insert';
import {ISelectBuilder, SelectBuilder} from "./builder/select";
import {DeleteBuilder, IDeleteBuilder} from "./builder/delete";
import {IUpdateBuilder, UpdateBuilder} from "./builder/update";
import {Executor, freezeBuilder} from './util';
import {required} from './util/assertion';

type ID = number | string;

export interface IModelBuilder {
  table: string;

  getPrimaryKey(): string | string[];

  create(values: Record<string, any>): IInsertBuilder;

  get(columns?: Array<string> | string): ISelectBuilder;

  getOne(columns?: Array<string> | string): ISelectBuilder;

  getLast(columns?: Array<string> | string): ISelectBuilder;

  getById(id: ID | Record<string, ID>, columns?: Array<string> | string): ISelectBuilder;

  delete(where?: Record<string, any>): IDeleteBuilder;

  deleteById(id: ID | Record<string, ID>): IDeleteBuilder;

  update(values: Record<string, any>): IUpdateBuilder;

  updateById(id: ID | Record<string, ID>, values: Record<string, any>): IUpdateBuilder;
}

function composite (key, data) {
  required(data[key], `miss "${key}" for composite keys.`);
  return data[key];
}

export class ModelBuilder implements IModelBuilder {
  static execute: Executor;

  primaryKey?: string;
  compositeKeys?: string[];

  constructor(public table: string, keys: string | string[] = 'id') {
    if (typeof keys === 'string') {
      this.primaryKey = keys;
    } else if (Array.isArray(keys)) {
      this.compositeKeys = keys;
    } else {
      throw new Error('keys must be a string or an array.');
    }
  }

  create(values: Record<string, any>): IInsertBuilder {
    return freezeBuilder(
      new InsertBuilder()
        .into(this.table)
        .setSome(values),
      ModelBuilder.execute
    );
  }

  getPrimaryKey(): string | string[] {
    return this.primaryKey || this.compositeKeys;
  }

  get(columns?: Array<string> | string): ISelectBuilder {
    return freezeBuilder(
      new SelectBuilder()
        .from(this.table)
        .select(columns),
      ModelBuilder.execute
    );
  }

  getOne(columns?: Array<string> | string): ISelectBuilder {
    return this.get(columns).take(1);
  }

  getLast(columns?: Array<string> | string): ISelectBuilder {
    if (this.primaryKey) {
      return this
        .getOne(columns)
        .orderBy(this.primaryKey, true);
    }
    return this.compositeKeys.reduce(function (selector, key) {
      return selector.orderBy(key, true);
    }, this.getOne(columns));
  }

  getById(id: ID | Record<string, ID>, columns?: Array<string> | string): ISelectBuilder {
    if (this.primaryKey) {
      return this.get(columns).where(this.primaryKey, '=', id) as ISelectBuilder;
    }
    return this.compositeKeys.reduce(function (selector, key) {
      required(id[key], `miss "${key}" for composite keys`);
      return selector.where(key, '=', id[key]) as ISelectBuilder;
    }, this.get(columns));
  }

  delete(where?: Record<string, any>): IDeleteBuilder {
    const builder = freezeBuilder(
      new DeleteBuilder().from(this.table),
      ModelBuilder.execute
    );

    if (!where) {
      return builder;
    }

    Object.keys(where).forEach(op => {
      const values = where[op];

      // {'<>': 'value'}
      // {'>': 10}
      if (typeof values !== 'object') {
        builder.where(values, op);
      }
      // {'>': ['c1','c2' ...]}
      else if (Array.isArray(values)) {
        values.forEach(value => builder.where(op, value));
      }
      // {'=': {c1: v1, c2: v2}}
      else {
        Object.keys(values).forEach(key => {
          builder.where(key, op, values[key]);
        });
      }
    });

    return builder;
  }

  deleteById(id: ID | Record<string, ID>): IDeleteBuilder {
    const deleter = new DeleteBuilder().from(this.table);
    if (this.primaryKey) {
      deleter.where(this.primaryKey, '=', id);
    } else {
      this.compositeKeys.forEach(function (key) {
        deleter.where(key, '=', composite(key, id));
      });
    }
    return freezeBuilder(
      deleter,
      ModelBuilder.execute
    );
  }

  update(values: Record<string, any>): IUpdateBuilder {
    return freezeBuilder(
      new UpdateBuilder()
        .from(this.table)
        .setSome(values),
      ModelBuilder.execute
    );
  }

  updateById(id: ID | Record<string, ID>, values: Record<string, any>): IUpdateBuilder {
    if (this.primaryKey) {
      return this.update(values).where(this.primaryKey, '=', id) as IUpdateBuilder;
    }
    return this.compositeKeys.reduce(function (updater, key) {
      return updater.where(key, '=', composite(key, id)) as IUpdateBuilder;
    }, this.update(values));
  }
}
